---
marp: true
theme: default
paginate: true
class: lead
---

# TanStack Query – Partie 2 : approfondissement

---

# Anatomie d'une Query

```js
const { data, isLoading, isError, error, refetch } = useQuery({
  queryKey: ["users"],
  queryFn: fetchUsers,
  staleTime: 1000 * 60, // 1 minute
  cacheTime: 1000 * 60 * 5, // 5 minutes
})
````

### Détails :

* **queryKey** : identifiant unique de la requête (clé du cache).
* **queryFn** : fonction de récupération des données.
* **staleTime** : durée pendant laquelle les données sont considérées "fraîches".
* **cacheTime** : durée avant suppression du cache inactif.
* **refetch** : permet de relancer la requête manuellement.

---

# États automatiques de TanStack Query

| État              | Description                          |
| ----------------- | ------------------------------------ |
| **isLoading**     | Pendant la première requête          |
| **isFetching**    | Pendant un rechargement de données   |
| **isError**       | Quand la requête échoue              |
| **isSuccess**     | Quand les données sont prêtes        |
| **dataUpdatedAt** | Timestamp de la dernière mise à jour |

> Ces états remplacent les `useState` et `useEffect` classiques.

---

# Configuration globale

```js
import { QueryClient, QueryClientProvider } from "@tanstack/react-query"

const client = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false,
      staleTime: 1000 * 30,
    },
  },
})
```

```jsx
<QueryClientProvider client={client}>
  <App />
</QueryClientProvider>
```

* Fournit un **client global** à toute l'application.
* Configure des **options par défaut** (staleTime, retry, etc.).

---

# Mutations : modifier des données

```js
import { useMutation, useQueryClient } from "@tanstack/react-query"

function AddUser() {
  const queryClient = useQueryClient()

  const mutation = useMutation({
    mutationFn: (user) =>
      fetch("/api/users", {
        method: "POST",
        body: JSON.stringify(user),
      }),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["users"] })
    },
  })

  return (
    <button onClick={() => mutation.mutate({ name: "Alice" })}>
      Ajouter un utilisateur
    </button>
  )
}
```

---

✅ Invalide la liste des utilisateurs pour forcer le rechargement.

---

# Mise à jour optimiste (optimistic update)

Avant même la réponse serveur, l'UI peut être mise à jour localement :

```js
const mutation = useMutation({
  mutationFn: updateUser,
  onMutate: async (newUser) => {
    await queryClient.cancelQueries(["user", newUser.id])
    const previous = queryClient.getQueryData(["user", newUser.id])
    queryClient.setQueryData(["user", newUser.id], newUser)
    return { previous }
  },
  onError: (err, newUser, context) => {
    queryClient.setQueryData(["user", newUser.id], context.previous)
  },
  onSettled: (newUser) => {
    queryClient.invalidateQueries(["user", newUser.id])
  },
})
```

---

> Permet des interactions instantanées côté client, avec rollback en cas d'erreur.

---

# Refetch et Invalidation

* **Refetch** = relancer une requête en direct :

  ```js
  refetch()
  ```

* **Invalidation** = marquer des données comme obsolètes :

  ```js
  queryClient.invalidateQueries({ queryKey: ["users"] })
  ```

> Le refetch sera effectué automatiquement dès que la query redeviendra active.

---

# Integration avec TanStack Router

```js
export const Route = createFileRoute('/users/$id')({
  loader: ({ params }) => 
    queryClient.ensureQueryData({
      queryKey: ['user', params.id],
      queryFn: () => fetch(`/api/users/${params.id}`).then(r => r.json()),
    }),
  component: UserPage,
})
```

✅ Données préchargées avant le rendu.
✅ `useQuery` retrouve ensuite la donnée depuis le cache, sans refetch.

---

# React Query Devtools

```bash
npm install @tanstack/react-query-devtools
```

```jsx
import { ReactQueryDevtools } from "@tanstack/react-query-devtools"

<QueryClientProvider client={client}>
  <App />
  <ReactQueryDevtools initialIsOpen={false} />
</QueryClientProvider>
```

> Interface de débogage visuelle pour suivre le cache, les requêtes, et les mutations.

---

# Synthèse

| Concept                 | Rôle principal                   |
| ----------------------- | -------------------------------- |
| `useQuery`              | Lecture et cache automatique     |
| `useMutation`           | Écriture et invalidation         |
| `queryClient`           | Cœur de la synchronisation       |
| `refetch / invalidate`  | Mise à jour des données          |
| `staleTime / cacheTime` | Performance et contrôle du cache |

> TanStack Query simplifie la gestion des données serveur et garantit des UI réactives et cohérentes.

---

# Pour aller plus loin

* Documentation : [https://tanstack.com/query/latest](https://tanstack.com/query/latest)
* Devtools : [@tanstack/react-query-devtools](https://tanstack.com/query/latest/docs/framework/react/devtools)
* Exemple API : [PokéAPI](https://pokeapi.co)
* Concepts avancés : Prefetch, Infinite Queries, Suspense, SSR.


---

## Merci d'avoir écouter cette première partie

Pour revenir à la page d'accueil

[Plan du cours](https://antoine07.github.io/react_web2/#2)


