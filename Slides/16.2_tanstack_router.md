---
marp: true
theme: default
paginate: true
class: lead
---


### Définition aramètres de route (`path params`)

Les *path params* servent à capturer une **segment dynamique unique** dans l'URL (texte jusqu'au " / ") via une variable nommée.

On les déclare dans le chemin de route en préfixant le nom par un signe dollar : par ex. `/posts/$postId`, `/team/$teamId`.

* Exemple d'usage (fichier ):

  ```tsx
  export const Route = createFileRoute('/posts/$postId')({
    loader: async ({ params }) => {
      return fetchPost(params.postId)
    },
  })
  ```

  Ici, `params.postId` sera la valeur de l'URL (ex : `/posts/123` → `postId = '123'`)

---

### Pokemon

```jsx
import { createFileRoute } from "@tanstack/react-router";

export const Route = createFileRoute("/pokemon/$name")({
  loader: async ({ params }) => {
    const response = await fetch(
      `https://pokeapi.co/api/v2/pokemon/${params.name}`
    );
    if (!response.ok) {
      throw new Error("Pokémon introuvable");
    }
    return response.json();
  },
  component: Pokemon,
});
```

---

### Dans votre composant 

```jsx
// Composant principal de la route
function PokemonPage() {
  const pokemon = Route.useLoaderData()
  const { name } = Route.useParams()

  return (
    <div>
      <h1>{name}</h1>
      <img
        src={pokemon.sprites.front_default}
        alt={name}
      />
      <ul >
        <li>Poids : {pokemon.weight}</li>
        <li>Taille : {pokemon.height}</li>
        <li>Types : {pokemon.types.map(t => t.type.name).join(', ')}</li>
      </ul>
    </div>
  )
}

```

---

### En résumé

Le `loader` sert à **charger les données avant le rendu** du composant.
Il permet :

1. d'afficher la page avec les données déjà prêtes (sans état de chargement) ;
1. de centraliser la logique de fetch dans la route, pas dans le composant ;
1. d'optimiser le SSR et le préchargement (navigation fluide).

On peut combiner cette approche avec Tanstack Query, que nous verrons plus tard dans le cours.

---

### Navigation 

Dans un composant attaché à une route, on peut utiliser `Route.useParams()` pour accéder aux valeurs capturées :

  ```tsx
  function PostComponent() {
    const { postId } = Route.useParams()
    return <div>Post {postId}</div>
  }
  ```

--- 


### **Accéder aux paramètres dans le contexte courant**

Dans un composant associé directement à une route dynamique, les paramètres s'obtiennent avec :

  ```tsx
  const { postId } = Route.useParams()
  ```
Exemple : pour une route `/blog/$postId`, l'URL `/blog/123` donne `postId = '123'`.
Cette méthode est **strictement liée** à la route correspondante.

---

### **Accéder aux paramètres hors du contexte direct**


Il est possible d'obtenir les paramètres d'une sous-route depuis un composant parent ou un layout partagé.
L'option `{ strict: false }` autorise cette récupération élargie :

  ```tsx
  import { useParams } from '@tanstack/react-router'

  const params = useParams({ strict: false })
  ```
Exemple : depuis la page `/blog`, si la sous-route active est `/blog/123`, `params.postId` renverra `"123"`.

---

### **Navigation vers une route paramétrée**

Lors d'une navigation vers une route contenant des paramètres, ceux-ci doivent être fournis explicitement.

  ```tsx
  <Link to="/blog/$postId" params={{ postId: '123' }}>
    Article 123
  </Link>
  ```
Version fonctionnelle pour récupérer des paramètres de routes imbriquées

  ```tsx
  <Link
    to="/blog/$postId"
    params={prev => ({ ...prev, postId: '123' })}
  >
    Article 123
  </Link>
  ```
Cette forme permet de **conserver ou ajuster** d'autres paramètres existants au moment de la navigation.

### Paramètres optionnels

Les *paramètres optionnels* sont déclarés avec `{-$paramName}` :

  ```tsx
  createFileRoute('/posts/{-$category}')
  ```

Ceci permettra de matcher aussi bien `/posts` que `/posts/tech`. Si absent, `params.category` sera `undefined`.
Conseils/pratiques :

1. Toujours typifier l'usage des params (ex : TypeScript sait qu'un param optionnel peut être `undefined`).
1. Utiliser les patterns de préfixe/suffixe pour URLs propres et expressives.
1. Vérifier les valeurs dans `beforeLoad` ou `loader` si besoin (ex : validation d'un ID, d'un slug).

---

### **Validation et routing**

Assurez-vous d'avoir les dépendances suivantes d'installées :

```bash
npm install @tanstack/react-router zod
```

---

### **Définition de la route avec validation Zod**

```jsx
// routes/shop.jsx
import { createFileRoute } from '@tanstack/react-router'
import { z } from 'zod' // module de validation

// Schéma Zod pour typer et valider les paramètres de recherche
const searchSchema = z.object({
  page: z.number().default(1),
  sortBy: z.string().default('price'),
  desc: z.boolean().default(false),
  categories: z.array(z.string()).default([]),
})

// Définition de la route avec validation
export const Route = createFileRoute('/shop')({
  validateSearch: searchSchema.parse, // Validation automatique via Zod
  component: ShopPage,
})
```

---

### **Utilisation dans le composant**

```jsx
import { useSearch, useNavigate } from '@tanstack/react-router'

function ShopPage() {
  const { page, sortBy, desc, categories } = useSearch({ from: '/shop' })
  const navigate = useNavigate({ from: '/shop' })

  return (
    <div className="p-6 space-y-4">
      <h1 className="text-2xl font-semibold">Boutique</h1>

      <p>Page : {page}</p>
      <p>Tri : {sortBy} ({desc ? 'descendant' : 'ascendant'})</p>
      <p>Catégories : {categories.join(', ') || 'aucune'}</p>

      <button
        onClick={() =>
          navigate({
            search: (prev) => ({ ...prev, page: prev.page + 1 }),
          })
        }
        className="px-4 py-2 bg-blue-500 rounded-md"
      >
        Page suivante
      </button>
    </div>
  )
}
```

---

### **Exemple de lien avec search-params**

```jsx
<Link
  to="/shop"
  search={{
    page: 2,
    sortBy: 'name',
    desc: true,
    categories: ['electronics', 'gifts'],
  }}
>
  Voir les produits triés
</Link>
```

---

### **Résultat**

L'URL générée :

  ```
  /shop?page=2&sortBy=name&desc=true&categories=electronics&categories=gifts
  ```
`Zod` garantit que les valeurs sont **converties, typées et valides*avant d'être utilisées dans le composant.
En cas de valeur incorrecte (ex. `page=abc`), le schéma applique la **valeur par défaut** (`1`).

---
### Des données non valides

```js
<Link
  to="/shop"
  search={{
    page: "deux", // ❌ string invalide
    sortBy: "name",
    desc: true,
    categories: ["electronics"],
  }}
>
  Produits
</Link>
```

---

### Gestion des erreurs

```js
import { createFileRoute } from '@tanstack/react-router'
import { searchSchema } from '@/schemas/searchSchema'
import ShopPage from '@/pages/ShopPage'

// Définition de la route avec validation
export const Route = createFileRoute('/shop')({
  validateSearch: searchSchema.parse, // Validation automatique via Zod
  component: ShopPage,
  errorComponent: ({ error }) => (
    <div className="p-6 text-red-500">
      <h2>Erreur de validation des paramètres</h2>
      <pre>{error.message}</pre>
    </div>
  ),
})
```

---

## **Pourquoi le schéma est souvent dans la route**

TanStack Router exécute la fonction `validateSearch` **au niveau du routeur**, avant que le composant ne soit rendu.
Ce n'est donc **pas une logique d'interface**, mais bien une logique de **validation de navigation**.
C'est pour cela que l'on passe une fonction comme :

```js
validateSearch: searchSchema.parse
```

directement à la définition de la route.

Cela garantit :

que les search params sont toujours valides avant l'affichage,
que `Route.useSearch()` renvoie des données déjà typées.

---

## **Bonne pratique : séparation du schéma**

Pour éviter de "polluer" les fichiers de routes avec trop de logique, il est recommandé de **définir le schéma Zod dans un module séparé**, puis de **l'importer**.

### Exemple d'architecture

```
src/
  routes/
    shop.jsx
  schemas/
    shopSearchSchema.js
```

### Fichier `schemas/shopSearchSchema.js`

```js
import { z } from 'zod'

export const shopSearchSchema = z.object({
  page: z.number().default(1),
  sortBy: z.string().default('price'),
  desc: z.boolean().default(false),
  categories: z.array(z.string()).default([]),
})
```

### Fichier `routes/shop.jsx`

```jsx
import { createFileRoute } from '@tanstack/react-router'
import { shopSearchSchema } from '../schemas/shopSearchSchema'

export const Route = createFileRoute('/shop')({
  validateSearch: shopSearchSchema.parse,
  component: ShopPage,
})

function ShopPage() {
  const search = Route.useSearch()
  return <div>Page actuelle : {search.page}</div>
}
```

---

## **Pourquoi ce n'est pas une "erreur de conception"**

C'est une approche **data-driven**, pas UI-driven.
La validation des paramètres d'URL (search ou path) fait partie de la **définition de la route**, au même titre que :

1. le `path`,
1. les `loader`,
1. ou les `beforeLoad`.

Cela permet de **séparer la logique métier (validation)** de la **logique de rendu (composant)**.

---

### En résumé

| Éléments        | Où les placer      | Pourquoi                                  |
| --------------- | ------------------ | ----------------------------------------- |
| Schéma Zod      | dossier `schemas/` | Centraliser la validation réutilisable    |
| validateSearch  | dans la route      | Garantir une URL valide avant rendu       |
| Composant React | séparé             | N'affiche que des données sûres et typées |

---


### **Gestion de la page "Not Found"**

**Titre :** Page d’erreur 404 avec TanStack Router
**Contenu :**

* TanStack Router permet de gérer les routes inexistantes via la propriété `notFoundComponent` du routeur.
* Cette approche garantit qu’une page claire s’affiche lorsque l’utilisateur accède à une URL non reconnue.

**Exemple :**

```jsx
import { createRouter, RouterProvider } from '@tanstack/react-router'
import { routeTree } from './routeTree.gen'

function NotFound() {
  return (
    <div className="p-10 text-center">
      <h1 className="text-3xl font-bold">404 - Page introuvable</h1>
      <p className="mt-4 text-gray-400">
        La ressource demandée n’existe pas.
      </p>
    </div>
  )
}

const router = createRouter({
  routeTree,
  notFoundComponent: NotFound, // composant 404 global
})

export function App() {
  return <RouterProvider router={router} />
}
```

**Principes :**

`notFoundComponent` agit comme un **fallback global**.
Il s’applique à toute navigation vers une route absente de la configuration.
On peut y ajouter un lien de retour ou un design cohérent avec le reste du site.

---

## Merci d'avoir écouter cette première partie

Pour revenir à la page d'accueil

[Plan du cours](https://antoine07.github.io/react_web2/#2)

